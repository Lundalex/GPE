<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="S-Html-Inputs.JS"></script>
    <script src="S-Important-Extensions.JS"></script>
    <script src="S-User-Events.JS"></script>
    <!-- <link rel="stylesheet" href="ThirdPartyCss.CSS"> -->
    
    <title>Unity(TM)</title>
</head>
<body onclick="OnClickFunction(event)" onmousedown="MouseDownFunction(event)" onmouseup="MouseUpFunction(event)" onwheel="ScrollFunction(event)" style="background-color: #909090">
    
    <div style="display: flex; flex-direction: row">
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXUAAACHCAMAAADeDjlcAAAAgVBMVEX///8RCwkAAAD29vYLAgDCwcGmpaUfGxkFAABdW1usq6owLSzFxMRpZ2fNzc0/PTzU09N
    LSEgNBQB5d3e0s7Pq6urk5OTu7u4mIiE4NTT5+fmioaHb29tVU1KTkpKCgYEaFRQsKShHRURYVlZ+fHxycHBmZGONjIsWEQ81MjEjHx2eXKxYAAANTUlEQVR4nO2d53rqMAyGi1mhg7LKLi0tnfd/gScJIVj
    y5xVC1un3q09LinlxLFmSlZubMjTajLulvPF/q+3mXYQ6lD2O/0fb3mdEvNVqdb7LHsv/ofntQ0I8lpiXPaDGazGbtkLik9ZZolf2oBqtdvewDIl3WlRiUPbAGqv1/dcPIH7EXvbgmqnh7jEkHiDiMfVh2QNs
    nEa7sYl4TP2r7EE2SolDbiIeKbgre6CN0fz204X4cbIvyh5tE/Q0+3AmHlOflT3iugs45HbqH2WPus5qd1+QQ27V5M93zK67LMSPk31b9thrqy/3hVyhvil78HXVU3boLTEue/R11fMF1P+CAhl1fwn0lrgve/z
    11KvVjnYMLrx4KXv8tdTGPNUj4t/TWftNE5Dp9Mv+AHVU2wA9Iv46nT2FL7vVT/ansj9CDfWgwSkRvzF+N+K23A9QR40Qzoh4PyUe6cNA/bO80ddVd3y5TojTWCL8blLsJQ1dp/Xz4Kzn9vkP3XfpD2VmBuhyD
    YlH+qHfDQ2QiVEJAzdoLWRJ1G/l35d4h67PEcZ4HT8A4jeKKRVLgl3sih62WWt5tJS69PuH8gZ4EFbiN+xjRAv5jPwieCx0zFZVjHr7p7/c361Wq8dQb2/jcRQKsBCPNGXUFyxwI3+yCqha1Nst0QkVnBRtOMN
    13Ew81JYxDheUJdnOimpVmVaK+iJQHJGJsBGPtCKmNC5upKFhMb364H1UJepPao3FxCklwU1pFO0aCvp/rj14L1WI+lyF3nGCvqZJJvEe/5Z9E5VKKFWH+lxN0LlBV01p/NsBXWIqlVCqDPVtZujAlEaiy454vub
    gfWXYJRVKfYSgu9WeP9LNayv5Nfcdrzf2HFUs9ZFa4xI4Qp8BUxpr38G/r7IKpT5E0B2D4vRSaSVhvmMtqkyLpA7Sos7QD2yqny+jvmPn90qDz1UFUu8i6I41odyUyjNa+30Uofn97WbTm438QhHFUZ+p0EXgWoj
    LTGlH/tsnXWIKrDKdDc4eyt3O40AaoU4KNNf5jhCkO0XHFTo3pV39H21T51t25uABj5X8iuSdiAuYvG5H6hUCIZ65B9xWPMfTzwqL0136Ri7RzCCyVAeG6qsegN5yLjnXmtJICy/fUU5ZYepjeSIm1Psd/gb3Kjr
    Bw0DqLqmFak8mR8XUyTKcbL8VTcXkLMPxQ1B0IV6d18IX89JNc3+WhNKdzC879S9YAyv6ZGiAuqE6/Pix6I2LEdHXaOfuDkDvO0OfG0yp+t8tCaV8qOty5nT3kYU6mWF4HhOvTZ/JAZW64tfd6r+xlCr/O81gB2/G
    f5YL9RcN9Gh00tTLQp14a8EPGuDB/sXcwDGKpbuxNprSWD4JpTyo6wuhwr/uz/8pC3W6XsKNOz1VrllgDgD63sNDYqYUmGxav2ROKOVA3VzvLZVbZqJO/A601Sa3ti7cB5ZA4XNMkZtS8O0z39HYtuRy6pO9uQj2PM
    JM1Elx2yRQx0fWa41zCeroBFytNLKZ0kjUd0zDkVCXU4fenzzEtMBFpY789eD0y8T/Ibs+METy/ng5/QTQVyYqJgbaFB1NqBqjmDlQP6vTgf7jyX1UqXdj3cv3b/B224u1SQCSPZB6tJCYW9y1YgCgexWtsOCN5oZi
    vqOpbUlu1KNCkrufPjihmfquGXNJ1Fryv9oXGHDixQ86N6Uar5D6jrotXay8qIvf3nFKb3d8l9o5uTEZqZu5/pIFxjJ+CzeNmKevXTvIl9MBJihVPtQ75H7im8CTN5eROjFlfArRBQYEnR4BdL+Dcjw9pz0D82G97U
    7KhTrPOrJK49NVWbPVZFvIHHLyDQMneXUxdDdTGkn2Hc1vkgt15Z6jCZvTwp6VOvGEmZWimyh+5foOQPfM4LuZ0kiyk2tOxOZBHQyElI2cYo+ZKzP0UQG6+nAHZ70H0E1WDimgn9Vkhx/TKWDJnOZAHQWcFmgtzkyd
    LpjyLCLBWz7+dh9A9+2I5mpKI6XLna3oLgfqMOQgX3UKwGWmTjf98jSSdyb8o7ZbALpvftDZlEZKTbutrDeHiAD8XmUrd7oZstd+ySdv5agAYcJCH6BoN1SyBXPVrbMpjZX4jlZ7nUP0C06fWa7Ud5qFhIbGSP4GFO
    3GL/IVvdqShU6WQmtNUw7U4db3Plfq1EycjabsU9J5CIp2L5d1S3v0d+xFSDlQh+Vl+VKnu/oU70K73l8Fur1EOvYd1TyTohyow8RsztRp1noGriNIQNFuDnJo9R3dfA4nZGpCnbjs6T5HvgM6r+cXg6LdHDQR9txT6
    Mm6bH3rQv0AriUJDykrD4p285BLQVfoO7pU29WFOo1yHTsk0EjB2W9g5ynykku1dVs4HTetC/WbvVwudbyJ5WxFIGXFUWo6B7nEh8OJ4HJL1IZ6T72Y/IacBdKXilwiB54PwukIXm2o00U8+vyk+oitphc0B9TLgWf0
    tg5NqGpDnawn8Yu+wFukAuV1l8u6/TkGjOwGoD7Uadb6hka+1A2ypn+Xb0DAkkhgOn7XdgNgp96R3LAyqZO0ZPimdMlRS75A2XTo1T8M/MSOeVl88WQiWA2AnTr5cGVSl1eU0DuX3wHSQIWA3s1beP2Rcd95ilBYDYC
    Versy1GUAwYqs3LjFGTgO499vkbpD5hhL+oa2dyHU0Rc5qgx1KUEWLexyOEBTQQuOfvljZ8UwJoN6LuyzGABCHc2YTXWok5fJRLW5UNT91fdxdbyG2rDhP7/SYlCJI4Aam+xJEr5U6vR6+Wet9Roi7J79W2hFjcGgy
    suC2aDq8wJo2OVS1x4JMQQDwUlqX+zOBvXLwvKsgWXO0CZ6RVA39LhDM9dyCQxAej7+goZ16DlTWbQ2x2Q/iIlWI8i8LuH61PEpmESwZtjizqEMhyd2N4PKCthNk53uJXhiUKlYvD514zOH8D7f4h2DFjyeFRpuBpUd
    1jAtY7wkcS/lwdpKtX0h1A1A5oi6deKiJKofdmZQcc0eO9RuvAHZ5wjEoHvkMXoBB3evQ5361eJT7+yuQBLa3o0FVWl49UjlfRvgO7LXGA/hKQcZRFr+Dz7gdajzG05MVqvVEvleKLjiEM9GFUle2Gl6Ch46oqbeklJ
    C+7dWJ4Bm61rU13wMk6irJaK+APRc/MAFqr7zKHlcC2svXtaYxxLw8UntXok62eunL4D7jDd11XN6qOillaa8jaNq8lkDU0tnahgRla8vgDoMD0Lqymhde1aulwC7R1U1O2GnXOnbcG1vflKqvEe4FnV0w2HqihfjHM
    268ASBzaCy5oJWFwm6Y+nlm20R1IF10UQyJuz78Wgyj07LuGNnBvWb/Zk10rQntlEc+nT1B43pXIs6SC9rBs5iMcqnNwmdDHPGbjGo7pHJk7RLe+RdFUM93HayhU5DneVD/Zr4oVOQzmfDjAaVNblbuvxD0MmoFRmqa
    M0siPrN8Fe43KT8cJZfJ2J04tcZO4sEEg+Ippwc58JioHCfJF2+hnLKPKFOUu0a6pKSM/vajrGJus/kBZh6lkkl6R1gdz3zyw2q7LKy83GuzUtHA7kOIWqhkCxco8dxqsfkjQ7Tsz7g/n0oXTVODPr6Q74MxcTXw83h
    83n8/Pz+OT1gM4kPVboLdXJwPd9ObYr88DUeg3cfT3v20T/Ns5+XqraaZR6aR//CRKhriSN2/hyT81fOQre+TamftqPRtsrPdyfzLfDqN4L+Q4LJ8f/0dAaVLlzVasCeg+h0M7YD0Qp1o3LEzvoHpgG0i0x89UUnasa
    H5KDOa26tkXh0NLFz1Nigjk21FnPQfA9Kn4S6DLq1AWMG9RcOq1oPkblQ817f4Lt5CXXUvHNpeceesZms4PT5vxV7YFJGdcVvqG+lwvaSNueoe6xTp0FuUKM1jvuN1Xo4WEZ144d4uUYlHYU6JS9dnLe9alDp/6rag/
    AyCqa7PANfqkBMPxDLl66NPDCoNM5QtYc+ZpSG+qXL50w5IhDEPeNs5Ok2K1gqm6eKPeA0ozD1y59KFG4IQ22Pms/ni2O+KH6YrIE8N6g9VpJWj+f2WIUT6lewWefFIyave/wjs8QB69DbkAdXI+qTq9zHhJ+e/JKmA
    thUb8hD2uFzXzK76iYpT7xXH88eSVPlmlAv9vkxV5NCfSL6/rFGJ6GTe4A8CBenr/aN+FdVlHoE4XoxPV0H4vBNX8/klXtCmuq+J3Cqqi5x75bTa2640ZkaQF5zmrXlkUaqup669yeN5jk/QUkRSPEx8q2I/I+uA01D
    /MaCZX5yQjrnxxrq1Xq2aX3k1Phhop3qTUsjFaWLOik1Lo1UlAylcFZV7PnsdRIozHOe6o1KIxWqLTyn4ka9EWmkcrTdxFVoWag3Io1Unka7tzji7qVM9Tl/Ilrff/0oyVrzVG9GGql0tbsv6GlEOurNSCNVQovZh+M
    y/+c35qv57YOdfFPSSJXSdvNuJt+UNFLlNNqN9a5NU9JIldTwawVdm0tq0f7koNC1WSquTWPSSFXWYjadkGW+MWmkqou4Ng7PIvhTXtr2BjF536ca/ulSxa7NXxqpBA3/a7/xHzzqxZbcK1bsAAAAAElFTkSuQmCC" 
    style="height: 100px; width: 300px;">
    <div style="width: 530px;"></div>
    <h1 id="CameraDirection">Default Camera Orientation</h1>
</div>

    <div style="display: flex; flex-direction: row">
        
        <canvas id="Canvas" width="800" height="800" style="border:10px solid #a200ff;"></canvas>
        
        <div style="width: 10px;"></div>
        
        <div style="display: flex; flex-direction: column;" style="padding: 20px;" style="background-color: burlywood;">
            
            <h1 style="font-weight: bolder;">Camera:</h1>
            <button style="width: 150px;" onclick="ResetCameraOrientation()">Return to Default Orientation</button>
            <br>
            
            <div style="display: flex; flex-direction: column;">
                <div style="width: 180; height: 50; display: flex; flex-direction: row">
                    <div style="height: 50px; width: 50px ;background-color: rgb(69, 218, 32)"onclick="MoveLeft()">Left</div>
                    <div style="height: 50px; width: 50px; background-color: #0004ff;"onclick="MoveAhead()">Ahead</div>
                    <div style="height: 50px; width: 50px; background-color: rgb(69, 218, 32)"onclick="MoveRight()">Right</div>
                </div>
                <div style="width: 120; height: 50; display: flex; flex-direction: row">
                    <div style="height: 50px; width: 50px; background-color: #909090"></div>
                    <div style="height: 50px; width: 50px; background-color: rgb(69, 218, 32)"onclick="MoveBack()">Back</div>
                </div>
            </div>
            <br>
            <div style="display: flex; flex-direction: column;">
                <div style="width: 150; height: 50; display: flex; flex-direction: row">
                    <div style="height: 50px; width: 50px; background-color: #909090"></div>
                    <div style="height: 50px; width: 50px; background-color: rgb(255, 251, 0)"onclick="MoveUp()">Up</div>
                </div>
                <div style="width: 150; height: 50; display: flex; flex-direction: row">
                    <div style="height: 50px; width: 50px; background-color: #909090"></div>
                    <div style="height: 50px; width: 50px; background-color: rgb(203, 32, 218)"onclick="MoveDown()">Down</div>
                </div>
            </div>
            
            <h1 style="font-weight: bolder;">Settings:</h1>
            <button style="width: 150px;" onclick="AddCubeObject(0,0,0,1)">AddCubeObject</button>
            <button style="width: 150px;" onclick="AddSphereObject(0,0,0,1)">AddSphereObject</button>
            <div>
                <input type="radio" name="1" value="Manipulate Path" onchange="ChangeManipulatePath()"><label>Manipulate Path(/Velocity)</label><br>
                <input type="radio" name="1" value="Manipulate Point" onchange="ChangeManipulatePoint()"><label>Manipulate Point</label><br>
                <input type="radio" name="1" value="Manipulate Object" onchange="ChangeManipulateObject()"><label>Manipulate Object</label><br>
            </div>
            <button style="width: 150px; font-weight: 1000;" onclick="Start()">Start Program</button>
            <button style="width: 150px; font-weight: 1000;" onclick="QuickStart()">Quick Start</button>
            <br>

            <div>
                <input type="range" id="Elasticity" name="Elasticity" 
                min="0" max="1" value="0.5" step="0.01" onchange="UpdateElasticity()">
                <label for="Elasticity" id="ElasticityLabel">(Min. 0E) Elasticity (Physics Bound Objects) (Max. 1E)</label>
            </div>

            <br>
            
            
            <p>Settings - Rendering Engine</p>
            
            
            <div>
                <input type="range" id="Hertz" name="Hertz"
                min="1" max="50" onchange="UpdateHertz()" value="50">
                <label for="Hertz" id="HertzLabel">(Min. 1H) Hertz (Max. 50H)</label>
            </div>
            
            <div>
                <input type="range" id="Increment/Hertz" name="Increment/Hertz" 
                min="0.2" max="2" value="0.5" step="0.1" onchange="UpdateIncrementHertz()">
                <label for="Increment/Hertz" id="IncrementHertzLabel">(Min. 20%/H) Change%/Hertz (Max. 200%/H)</label>
            </div>

            <br>

            <div>
                <input type="range" id="FocalLength" name="FocalLength" 
                min="500" max="2000" value="700" step="100" onchange="UpdateFocalLength()">
                <label for="FocalLength" id="FocalLengthLabel">(Min. 500F) Focal Length (Max. 2000F)</label>
            </div>
            
            <br>


            
            
        </div>
        
        <div style="width: 50px;"></div>
        
        
        <div style="display: flex; flex-direction: column;">
            
            <!-- INSTRUCTIONS -->
            <p>(Arrowkeys, Shift, Spacebar) for movement (selected)</p>
            <p>Onscreen buttons for camera movement</p>
            <p>Onscreen buttons for camera movement</p>
            <p>(Manipulate Object + Scroll) for Scaling object</p>
            <p>(Key: "b") to show Animation Pathing</p>
            <p>(Key: "Backspace(Delete)") to Stop Program</p>
            <p>(Keys: "k", "l", "m", "n") to change Focus Animation Stage</p>
            <p>(Key: "v") to Stop Program</p>
            <p>(Key: "h") to show Hitboxes</p>
            <p>RegObject[n].Delete Property not tested!!!!!!!!!</p>
        </div>
        
        <script>
            // All Global Variables
            let canvas = document.getElementById("Canvas")
            let ctx = canvas.getContext("2d")
            let context = canvas.getContext('2d')


            RegObjects = []

            SpawnerObjects = []


            let SpherePresetX = [10, 11.25, 10, 11.25, 10, 11.25, 10,   7.5, 10, 7.5, 5, 7.5, 5,         3.75, 5, 3.75, 5,  3.75, 5,       7.5,  5,  7.5,  10, 7.5,  10,      7.5,  5,  7.5,  5,  7.5,  10,        7.5, 5,  7.5, 5, 7.5, 10,     10,        5,  5,  10, 10, 10,     10, 5,   5,  10,  10,  5,  5,  5,  5]
            let SpherePresetY = [10, 7.5,  10, 7.5,  5,  7.5,  5,       3.75, 5,  3.75, 5, 3.75, 5,      7.5, 5, 7.5, 10, 7.5, 10,         7.5,  5,  7.5,  5,  7.5,  10,      11.25, 10, 11.25, 10, 11.25, 10,     7.5, 10, 7.5, 5, 7.5, 5,      10,        10, 5,  5, 10, 5,       5,  5,   10, 10,  10,  10, 10, 5,  5]
            let SpherePresetZ = [5,  7.5,  10, 7.5,  5,  7.5,  10,      7.5, 5,  7.5, 5, 7.5, 10,        7.5, 5, 7.5, 5,  7.5, 10,         11.25, 10, 11.25, 10, 11.25, 10,   7.5,  10, 7.5,  5,  7.5,  5,         3.75, 5,  3.75, 5, 3.75, 5,   5,         5,  5,  5, 5, 5,        10, 10,  10, 10,  5,   5,  10, 10, 5]
            
            let CubePresetX = [100-100,200-100,200-100,100-100,100-100,100-100,200-100,200-100,100-100,100-100,100-100,200-100,200-100,200-100,200-100,100-100,100-100]
            let CubePresetY = [100-100,100-100,200-100,200-100,100-100,100-100,100-100,200-100,200-100,100-100,100-100,100-100,100-100,200-100,200-100,200-100,200-100]
            let CubePresetZ = [100-100,100-100,100-100,100-100,100-100,200-100,200-100,200-100,200-100,200-100,100-100,100-100,200-100,200-100,100-100,100-100,200-100]

            
            let KeyPress = ""
            
            let Manipulate = ""
            
            let ScrollY = "None"
            
            
            let FocalLength = 700
            
            let FrameAmount = 10000
            
            let FoundObjectNumber = 0
            
            // GenerateInfArrForObjectAnimationInstructions()
            
            let AnimationX = []
            let AnimationY = []
            let AnimationZ = []
            
            let ChosenPathStage = 0
            
            let LastMouseDownX = 0
            let LastMouseDownY = 0
            
            let LastMouseUpX = 0
            let LastMouseUpY = 0
            
            let ProgramHertz = 50
            let ProgramIncrementHertz = 0.5
            
            let ShowAnimationPathing = false

            let ShowHitboxes = false
            
            let Framestage = 0
            
            let RunProgram = false



            let Elasticity = 0.5

            let TimeFriction = 1

        // SpawnerObjects.push(new NewSpawnerObject(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0))
        // SpawnerObjects[0].Spawn()


            let CameraMoveMode = 1
            
            let CameraDirection1 = 1 // 1 = X
            let CameraDirection2 = 2 // 2 = Y
            let CameraDirection3 = 3 // 3 = Z
            
            let AddedXDistance = 0
            let AddedYDistance = 0
            let AddedZDistance = 400
            // All Global Variables
            

            function MainLoop(){
                
                ResetCanvas() //

                // (Manipulate path, object, point)
                DoManipulation()
                
                DoScaling()
                
                DoCalculateAnimation()

                DoCalculatePhysics()
                
                // Prepare Projection Arrays
                ProjectShell2D()
                
                ProjectAnimationPath2D()

                ProjectHitboxes2D()
                //
                
                // Draw On Canvas
                CanvasDrawObjectShells()
                
                CanvasDrawAnimationPathing()

                CanvasDrawHitboxes()
                //
                
                KeyPress = "NoKey"
                ScrollY = "None"
                
                

                const TestCameraArr = ApplyCameraPerspective(1,2,3)

                if((TestCameraArr[0] == 1) && (TestCameraArr[1] == 2) && (TestCameraArr[2] == 3)){
                
                    document.getElementById("CameraDirection").innerHTML = "Default Camera Orientation"
                    document.getElementById("CameraDirection").style.color = "lightgreen"
                }
                else{
                    document.getElementById("CameraDirection").innerHTML = "Not Default Camera Orientation"
                    document.getElementById("CameraDirection").style.color = "red"
                }
                


                if(RunProgram == true){
                    setTimeout(MainLoop, 1000/ProgramHertz)
                }
                else{
                    ResetCanvas()
                }
            }
            // END OF MAIN LOOP
            
            
            
            
            
            // Reset Canvas Function
            function ResetCanvas(){
                ctx.beginPath();
                ctx.rect(00, 00, 800, 800);
                ctx.fillStyle = "white";
                ctx.fill();
            }
            // Reset Canvas Function
            
            
            
            
            
            // Manipulate Path/Object/Point Function
            function DoManipulation(){
                if(Manipulate == "Path"){
                    if(RegObjects[FoundObjectNumber].ObjectType == "Animated"){

                    switch (KeyPress) {
                        case "ArrowDown":
                        RegObjects[FoundObjectNumber].AnimationInstructionsZ[ChosenPathStage] -= 40
                        
                        break;
                        case "ArrowUp":
                        RegObjects[FoundObjectNumber].AnimationInstructionsZ[ChosenPathStage] += 40
                        
                        break;
                        case "ArrowLeft":
                        RegObjects[FoundObjectNumber].AnimationInstructionsX[ChosenPathStage] -= 40
                        
                        break;
                        case "ArrowRight":
                        RegObjects[FoundObjectNumber].AnimationInstructionsX[ChosenPathStage] += 40
                        
                        break;
                        case "SpaceBar":
                        RegObjects[FoundObjectNumber].AnimationInstructionsY[ChosenPathStage] -= 40
                        break;
                        
                        case "Shift":
                        RegObjects[FoundObjectNumber].AnimationInstructionsY[ChosenPathStage] += 40
                        break;
                        
                        default:
                        break;
                    }
                }
                else if(RegObjects[FoundObjectNumber].ObjectType == "Physics"){
                    
                    switch (KeyPress) {
                        case "ArrowDown":
                        RegObjects[FoundObjectNumber].VelocityZ -= 40
                        
                        break;
                        case "ArrowUp":
                        RegObjects[FoundObjectNumber].VelocityZ += 40
                        
                        break;
                        case "ArrowLeft":
                        RegObjects[FoundObjectNumber].VelocityX -= 40
                        
                        break;
                        case "ArrowRight":
                        RegObjects[FoundObjectNumber].VelocityX += 40
                        
                        break;
                        case "SpaceBar":
                        RegObjects[FoundObjectNumber].VelocityY -= 40
                        break;
                        
                        case "Shift":
                        RegObjects[FoundObjectNumber].VelocityY += 40
                        break;
                        
                        default:
                        break;
                    }





                }







                }
                else if(Manipulate == "Point"){
                    
                    for (let i = 0; i < RegObjects[FoundObjectNumber].PointsMarked.length; i++) {
                        
                            
                            if(RegObjects[FoundObjectNumber].PointsMarked[i] == true){
                                
                                switch (KeyPress) {
                                    case "ArrowDown":
                                    RegObjects[FoundObjectNumber].ShellZ[i] -= 20
                                    
                                    break;
                                    case "ArrowUp":
                                    RegObjects[FoundObjectNumber].ShellZ[i] += 20
                                    
                                    break;
                                    case "ArrowLeft":
                                    RegObjects[FoundObjectNumber].ShellX[i] -= 20
                                    
                                    break;
                                    case "ArrowRight":
                                    RegObjects[FoundObjectNumber].ShellX[i] += 20
                                    
                                    break;
                                    case "SpaceBar":
                                    RegObjects[FoundObjectNumber].ShellY[i] -= 20
                                    
                                    break;
                                    case "Shift":
                                    RegObjects[FoundObjectNumber].ShellY[i] += 20
                                    
                                    break;
                                    
                                    default:
                                    break;
                                }
                            }
                        
                    }
                }
                
                else if(Manipulate == "Object"){
                    switch (KeyPress) {
                        case "ArrowDown":
                        RegObjects[FoundObjectNumber].LeaderZ -= 20
                        
                        break;
                        case "ArrowUp":
                        RegObjects[FoundObjectNumber].LeaderZ += 20
                        
                        break;
                        case "ArrowLeft":
                        RegObjects[FoundObjectNumber].LeaderX -= 20
                        
                        break;
                        case "ArrowRight":
                        RegObjects[FoundObjectNumber].LeaderX += 20
                        
                        break;
                        case "SpaceBar":
                        RegObjects[FoundObjectNumber].LeaderY -= 20
                        
                        break;
                        case "Shift":
                        RegObjects[FoundObjectNumber].LeaderY += 20
                        
                        break;
                        
                        default:
                        break;
                    }
                }
            }
            // Manipulate Path/Object/Point Function
            
            
            
            
            
            // Apply Scaling Function
            function DoScaling(){
                if(ScrollY != "None"){
                    
                    let Scalefactor = 0
                    
                    if(ScrollY == "Up"){
                        Scalefactor = 1.1
                    }
                    
                    else if (ScrollY == "Down"){
                        Scalefactor = 0.9
                    }

                    for (let i = 0; i < RegObjects[FoundObjectNumber].ShellX.length; i++) {
                        RegObjects[FoundObjectNumber].ShellX[i] *= Scalefactor
                        RegObjects[FoundObjectNumber].ShellY[i] *= Scalefactor
                        RegObjects[FoundObjectNumber].ShellZ[i] *= Scalefactor
                        
                    }
                }
            }
            // Apply Scaling Function
            
            
            
            
            
            // Calculate Animation Values per Frame Function
            function DoCalculateAnimation(){

                if(Framestage > 400){
                    Framestage = 1
                }
                else{
                    Framestage += 2 * ProgramIncrementHertz
                }
                
                for (let i = 0; i < RegObjects.length; i++) {
                    if(RegObjects[i].ObjectType == "Animated"){
                        let CurrentAnimationStage = Math.floor(Framestage/100)
                        let FrameInAnimationStage = Framestage % 100

                        
                        RegObjects[i].TotalAnimationDeviationX = 0
                        RegObjects[i].TotalAnimationDeviationY = 0
                        RegObjects[i].TotalAnimationDeviationZ = 0
                        
                        for (let o = 0; o < CurrentAnimationStage; o++) {
                            
                            RegObjects[i].TotalAnimationDeviationX += Number(RegObjects[i].AnimationInstructionsX[o])
                            RegObjects[i].TotalAnimationDeviationY += Number(RegObjects[i].AnimationInstructionsY[o])
                            RegObjects[i].TotalAnimationDeviationZ += Number(RegObjects[i].AnimationInstructionsZ[o])
                            
                        }
                        
                        RegObjects[i].TotalAnimationDeviationX += Number(RegObjects[i].AnimationInstructionsX[CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
                        RegObjects[i].TotalAnimationDeviationY += Number(RegObjects[i].AnimationInstructionsY[CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
                        RegObjects[i].TotalAnimationDeviationZ += Number(RegObjects[i].AnimationInstructionsZ[CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
                    }
                }

                
            
                if(ShowAnimationPathing == true){


                    for (let i = 0; i < RegObjects.length; i++) {

                        if(RegObjects[i].ObjectType == "Animated"){
                            

                            RegObjects[i].AnimationPathCoordsX = []
                            RegObjects[i].AnimationPathCoordsY = []
                            RegObjects[i].AnimationPathCoordsZ = []
                            
                            
                            RegObjects[i].AnimationPathCoordsX[0] = Number(RegObjects[i].AnimationInstructionsX[0])
                            RegObjects[i].AnimationPathCoordsY[0] = Number(RegObjects[i].AnimationInstructionsY[0])
                            RegObjects[i].AnimationPathCoordsZ[0] = Number(RegObjects[i].AnimationInstructionsZ[0])
                            
                            
                            for (let o = 1; o < RegObjects[i].AnimationInstructionsX.length; o++) {
                                
                                RegObjects[i].AnimationPathCoordsX[o] = Number(RegObjects[i].AnimationPathCoordsX[o-1]) + Number(RegObjects[i].AnimationInstructionsX[o])
                                RegObjects[i].AnimationPathCoordsY[o] = Number(RegObjects[i].AnimationPathCoordsY[o-1]) + Number(RegObjects[i].AnimationInstructionsY[o])
                                RegObjects[i].AnimationPathCoordsZ[o] = Number(RegObjects[i].AnimationPathCoordsZ[o-1]) + Number(RegObjects[i].AnimationInstructionsZ[o])
                            }
                        }
                    }
                }
            }
            // Calculate Animation Values per Frame Function
            





            // Calculate Hitboxes, Velocity, Collision Function
            // Everything Hitboxes & Velocity
            function DoCalculatePhysics(){

                for (let i = 0; i < RegObjects.length; i++) {

                    if(RegObjects[i].ObjectType == "Physics"){

                        for (let o = 0; o < RegObjects.length; o++) {

                            const Hitbox1 = RegObjects[i].HitboxRelativeBoundraryXYZ()
                            const NewHitbox1 = RegObjects[i].NextHitboxRelativeBoundraryXYZ()

                            if(RegObjects[o].ObjectType == "Physics" && i != o){

                                
                                const Hitbox2 = RegObjects[o].HitboxRelativeBoundraryXYZ()
                                const NewHitbox2 = RegObjects[o].NextHitboxRelativeBoundraryXYZ()
                                
                                if((((NewHitbox1[0] > NewHitbox2[0]) && (NewHitbox1[0] < NewHitbox2[1])) || ((NewHitbox1[1] > NewHitbox2[0]) && (NewHitbox1[1] < NewHitbox2[1]))) && (((NewHitbox1[2] > NewHitbox2[2]) && (NewHitbox1[2] < NewHitbox2[3])) || ((NewHitbox1[3] > NewHitbox2[2]) && (NewHitbox1[3] < NewHitbox2[3]))) && (((NewHitbox1[4] > NewHitbox2[4]) && (NewHitbox1[4] < NewHitbox2[5])) || ((NewHitbox1[5] > NewHitbox2[4]) && (NewHitbox1[5] < NewHitbox2[5])))){



                                    let CalculateNewVelocity = true 
                                    if(RegObjects[i].DeleteOnCollision == true){
                                        DeleteObject(i)
                                        CalculateNewVelocity = false
                                    }

                                    if(RegObjects[o].DeleteOnCollision == true){
                                        DeleteObject(o)
                                        CalculateNewVelocity = false
                                    }


                                    if(CalculateNewVelocity == true){


                                // Collision X

                                    // Elasticity = 0 Method
                                    const ForceX1 = RegObjects[i].Mass * RegObjects[i].VelocityX
                                    const ForceX2 = RegObjects[o].Mass * RegObjects[o].VelocityX

                                    const ForceTotalX = ForceX1 + ForceX2

                                    const NoneElasticityVelocityX1 = ForceTotalX / RegObjects[i].Mass
                                    const NoneElasticityVelocityX2 = ForceTotalX / RegObjects[o].Mass


                                    // Elasticity = 1 Method

                                    const MaxElasticityVelocityX1 = ForceX2 / RegObjects[i].Mass
                                    const MaxElasticityVelocityX2 = ForceX1 / RegObjects[o].Mass

                                    // Weighted

                                    RegObjects[i].VelocityX = ((NoneElasticityVelocityX1 * (1-Elasticity)) + (MaxElasticityVelocityX1 * Elasticity))
                                    RegObjects[o].VelocityX = ((NoneElasticityVelocityX2 * (1-Elasticity)) + (MaxElasticityVelocityX2 * Elasticity))

                                    
                                // Collision Y

                                    // Elasticity = 0 Method
                                    const ForceY1 = RegObjects[i].Mass * RegObjects[i].VelocityY
                                    const ForceY2 = RegObjects[o].Mass * RegObjects[o].VelocityY

                                    const ForceTotalY = ForceY1 + ForceY2

                                    const NoneElasticityVelocityY1 = ForceTotalY / RegObjects[i].Mass
                                    const NoneElasticityVelocityY2 = ForceTotalY / RegObjects[o].Mass


                                    // Elasticity = 1 Method

                                    const MaxElasticityVelocityY1 = ForceY2 / RegObjects[i].Mass
                                    const MaxElasticityVelocityY2 = ForceY1 / RegObjects[o].Mass

                                    // Weighted

                                    RegObjects[i].VelocityY = ((NoneElasticityVelocityY1 * (1-Elasticity)) + (MaxElasticityVelocityY1 * Elasticity))
                                    RegObjects[o].VelocityY = ((NoneElasticityVelocityY2 * (1-Elasticity)) + (MaxElasticityVelocityY2 * Elasticity))

                                    
                                // Collision Z

                                    // Elasticity = 0 Method
                                    const ForceZ1 = RegObjects[i].Mass * RegObjects[i].VelocityZ
                                    const ForceZ2 = RegObjects[o].Mass * RegObjects[o].VelocityZ

                                    const ForceTotalZ = ForceZ1 + ForceZ2

                                    const NoneElasticityVelocityZ1 = ForceTotalZ / RegObjects[i].Mass
                                    const NoneElasticityVelocityZ2 = ForceTotalZ / RegObjects[o].Mass


                                    // Elasticity = 1 Method

                                    const MaxElasticityVelocityZ1 = ForceZ2 / RegObjects[i].Mass
                                    const MaxElasticityVelocityZ2 = ForceZ1 / RegObjects[o].Mass

                                    // Weighted

                                    RegObjects[i].VelocityZ = ((NoneElasticityVelocityZ1 * (1-Elasticity)) + (MaxElasticityVelocityZ1 * Elasticity))
                                    RegObjects[o].VelocityZ = ((NoneElasticityVelocityZ2 * (1-Elasticity)) + (MaxElasticityVelocityZ2 * Elasticity))
                            }
                        }
                    }
                }
                // Add VelocityX
                if(RegObjects[i].VelocityX > 0){
                RegObjects[i].VelocityX -= TimeFriction * ProgramIncrementHertz

                if(RegObjects[i].VelocityX < 0){
                    RegObjects[i].VelocityX = 0
                }

                }
                else if(RegObjects[i].VelocityX < 0){
                RegObjects[i].VelocityX += TimeFriction * ProgramIncrementHertz

                if(RegObjects[i].VelocityX > 0){
                    RegObjects[i].VelocityX = 0
                }

                }
                if(RegObjects[i].VelocityX != 0){
                    RegObjects[i].LeaderX += RegObjects[i].VelocityX * ProgramIncrementHertz * 0.05
                }

                // Add VelocityY
                if(RegObjects[i].VelocityY > 0){
                RegObjects[i].VelocityY -= TimeFriction * ProgramIncrementHertz

                if(RegObjects[i].VelocityY < 0){
                    RegObjects[i].VelocityY = 0
                }

                }
                else if(RegObjects[i].VelocityY < 0){
                RegObjects[i].VelocityY += TimeFriction * ProgramIncrementHertz

                if(RegObjects[i].VelocityY > 0){
                    RegObjects[i].VelocityY = 0
                }

                }
                if(RegObjects[i].VelocityY != 0){
                    RegObjects[i].LeaderY += RegObjects[i].VelocityY * ProgramIncrementHertz * 0.05
                }

                // Add VelocityZ
                if(RegObjects[i].VelocityZ > 0){
                RegObjects[i].VelocityZ -= TimeFriction * ProgramIncrementHertz

                if(RegObjects[i].VelocityX < 0){
                    RegObjects[i].VelocityX = 0
                }

                }
                else if(RegObjects[i].VelocityZ < 0){
                RegObjects[i].VelocityZ += TimeFriction * ProgramIncrementHertz

                if(RegObjects[i].VelocityZ > 0){
                    RegObjects[i].VelocityZ = 0
                }

                }
                if(RegObjects[i].VelocityZ != 0){
                    RegObjects[i].LeaderZ += RegObjects[i].VelocityZ * ProgramIncrementHertz * 0.05
                }
            }
        }
    }
            // Calculate Hitboxes and Collision Function





            // Project Shell X/Y/Z -> 2D(X, Y) Function
            function ProjectShell2D(){
                for (let i = 0; i < RegObjects.length; i++) {

                        RegObjects[i].ShellprojectedX = []
                        RegObjects[i].ShellprojectedY = []
                        
                        for (let o = 0; o < RegObjects[i].ShellX.length; o++) {
                            // Add Animation Frame Values
                            const ShellPointX = RegObjects[i].ShellX[o] + RegObjects[i].LeaderX + Number(RegObjects[i].TotalAnimationDeviationX)
                            const ShellPointY = RegObjects[i].ShellY[o] + RegObjects[i].LeaderY + Number(RegObjects[i].TotalAnimationDeviationY)
                            const ShellPointZ = RegObjects[i].ShellZ[o] + RegObjects[i].LeaderZ + Number(RegObjects[i].TotalAnimationDeviationZ)

                            const XYZArr = ApplyCameraPerspective(ShellPointX, ShellPointY, ShellPointZ)

                            const X = XYZArr[0] + AddedXDistance
                            const Y = XYZArr[1] + AddedYDistance
                            const Z = XYZArr[2] + AddedZDistance
                            
                            
                            RegObjects[i].ShellprojectedX[o] = ((X * FocalLength) / (Z + FocalLength))
                            RegObjects[i].ShellprojectedY[o] = ((Y * FocalLength) / (Z + FocalLength))
                        }
                    
                }
            }
            // Project Shell X/Y/Z -> 2D(X, Y) Function
            




            // Camera Orientation Function
            function ApplyCameraPerspective(X, Y, Z){

                let NewX = 0
                let NewY = 0
                let NewZ = 0

                if(CameraDirection1 == 1){
                    NewX = X
                }
                else if(CameraDirection1 == -1){
                    NewX = -X
                }
                else if(CameraDirection1 == 2){
                    NewX = Y
                }
                else if(CameraDirection1 == -2){
                    NewX = -Y
                }
                else if(CameraDirection1 == 3){
                    NewX = Z
                }
                else if(CameraDirection1 == -3){
                    NewX = -Z
                }



                if(CameraDirection2 == 1){
                    NewY = X
                }
                else if(CameraDirection2 == -1){
                    NewY = -X
                }
                else if(CameraDirection2 == 2){
                    NewY = Y
                }
                else if(CameraDirection2 == -2){
                    NewY = -Y
                }
                else if(CameraDirection2 == 3){
                    NewY = Z
                }
                else if(CameraDirection2 == -3){
                    NewY = -Z
                }



                if(CameraDirection3 == 1){
                    NewZ = X
                }
                else if(CameraDirection3 == -1){
                    NewZ = -X
                }
                else if(CameraDirection3 == 2){
                    NewZ = Y
                }
                else if(CameraDirection3 == -2){
                    NewZ = -Y
                }
                else if(CameraDirection3 == 3){
                    NewZ = Z
                }
                else if(CameraDirection3 == -3){
                    NewZ = -Z
                }
                return [NewX, NewY, NewZ]
            }
            // Camera Orientation Function
            


            
            
            // Project per Object Animation Path X/Y/Z -> 2D(X, Y) Function
            function ProjectAnimationPath2D(){
                if(ShowAnimationPathing == true){
                    
                    for (let i = 0; i < RegObjects.length; i++) {

                        if(RegObjects[i].ObjectType == "Animated"){

                            
                            RegObjects[i].AnimationPathProjectedX = []
                            RegObjects[i].AnimationPathProjectedY = []
                            
                            for (let o = 0; o < RegObjects[i].AnimationInstructionsX.length; o++) {
                                
                                const TotalAnimationpointX = RegObjects[i].AnimationRelativePathCoordPositionX(o)
                                const TotalAnimationpointY = RegObjects[i].AnimationRelativePathCoordPositionY(o)
                                const TotalAnimationpointZ = RegObjects[i].AnimationRelativePathCoordPositionZ(o)

                                const XYZArr = ApplyCameraPerspective(TotalAnimationpointX, TotalAnimationpointY, TotalAnimationpointZ)

                                const X = XYZArr[0] + AddedXDistance
                                const Y = XYZArr[1] + AddedYDistance
                                const Z = XYZArr[2] + AddedZDistance
                                
                                RegObjects[i].AnimationPathProjectedX[o] = ((X * FocalLength) / (Z + FocalLength))
                                RegObjects[i].AnimationPathProjectedY[o] = ((Y * FocalLength) / (Z + FocalLength))
                            }

                            const TotalAnimationpointX = RegObjects[i].LeaderX
                            const TotalAnimationpointY = RegObjects[i].LeaderY
                            const TotalAnimationpointZ = RegObjects[i].LeaderZ

                            const XYZArr = ApplyCameraPerspective(TotalAnimationpointX, TotalAnimationpointY, TotalAnimationpointZ)

                            const X = XYZArr[0] + AddedXDistance
                            const Y = XYZArr[1] + AddedYDistance
                            const Z = XYZArr[2] + AddedZDistance
                                
                            RegObjects[i].AnimationPathProjectedX.unshift((X * FocalLength) / (Z + FocalLength))
                            RegObjects[i].AnimationPathProjectedY.unshift((Y * FocalLength) / (Z + FocalLength))
                        }
                    }
                }
            }
            // Project per Object Animation Path X/Y/Z -> 2D(X, Y) Function
            







            function ProjectHitboxes2D(){

                for (let i = 0; i < RegObjects.length; i++) {

                    if(RegObjects[i].ObjectType == "Physics"){

                        const Hitbox = RegObjects[i].HitboxRelativeBoundraryXYZ()
                        
                        const HitboxWireFrameX = [Hitbox[0],Hitbox[1],Hitbox[1],Hitbox[0],Hitbox[0],Hitbox[0],Hitbox[1],Hitbox[1],Hitbox[0],Hitbox[0],Hitbox[0],Hitbox[1],Hitbox[1],Hitbox[1],Hitbox[1],Hitbox[0],Hitbox[0]]
                        const HitboxWireFrameY = [Hitbox[2],Hitbox[2],Hitbox[3],Hitbox[3],Hitbox[2],Hitbox[2],Hitbox[2],Hitbox[3],Hitbox[3],Hitbox[2],Hitbox[2],Hitbox[2],Hitbox[2],Hitbox[3],Hitbox[3],Hitbox[3],Hitbox[3]]
                        const HitboxWireFrameZ = [Hitbox[4],Hitbox[4],Hitbox[4],Hitbox[4],Hitbox[4],Hitbox[5],Hitbox[5],Hitbox[5],Hitbox[5],Hitbox[5],Hitbox[4],Hitbox[4],Hitbox[5],Hitbox[5],Hitbox[4],Hitbox[4],Hitbox[5]]

                        for (let o = 0; o < HitboxWireFrameX.length; o++) {
                            

                            const XYZArr = ApplyCameraPerspective(HitboxWireFrameX[o], HitboxWireFrameY[o], HitboxWireFrameZ[o])
                            
                            const X = XYZArr[0] + AddedXDistance
                            const Y = XYZArr[1] + AddedYDistance
                            const Z = XYZArr[2] + AddedZDistance

                            RegObjects[i].HitboxProjectedX[o] = ((X * FocalLength) / (Z + FocalLength))
                            RegObjects[i].HitboxProjectedY[o] = ((Y * FocalLength) / (Z + FocalLength))
                            
                        }
                    }
                }
            }





            
            
            
            
            // Canvas Draw Object Shells with Marking Function
            function CanvasDrawObjectShells(){
                for (let i = 0; i < RegObjects.length; i++) {
                        // Object Marked
                        if(RegObjects[i].Marked == true){
                            for (let o = 0; o < RegObjects[i].ShellprojectedX.length; o++) {
                                
                                ctx.moveTo(400+Number(RegObjects[i].ShellprojectedX[o]),400+Number(RegObjects[i].ShellprojectedY[o]));
                                ctx.lineTo(400+Number(RegObjects[i].ShellprojectedX[o+1]),400+Number(RegObjects[i].ShellprojectedY[o+1]));
                                ctx.strokeStyle = "orange"
                                ctx.lineWidth = 2
                                ctx.stroke()
                            }
                            // Point Marked (in Marked Object)
                            for (let o = 0; o < RegObjects[i].ShellprojectedX.length; o++) {
                                
                                if(RegObjects[i].PointsMarked[o] == true){
                                    
                                    ctx.moveTo(400+Number(RegObjects[i].ShellprojectedX[o]-10),400+Number(RegObjects[i].ShellprojectedY[o]-10));
                                    ctx.lineTo(400+Number(RegObjects[i].ShellprojectedX[o]+10),400+Number(RegObjects[i].ShellprojectedY[o]+10));
                                    ctx.strokeStyle = "red"
                                    ctx.lineWidth = 2
                                    ctx.stroke()
                                    ctx.moveTo(400+Number(RegObjects[i].ShellprojectedX[o]+10),400+Number(RegObjects[i].ShellprojectedY[o]-10));
                                    ctx.lineTo(400+Number(RegObjects[i].ShellprojectedX[o]-10),400+Number(RegObjects[i].ShellprojectedY[o]+10))
                                    ctx.stroke()
                                }
                            }
                            
                        }
                        // Object Not Marked
                        else{
                            for (let o = 0; o < RegObjects[i].ShellprojectedX.length; o++) {
                                
                                ctx.moveTo(400+Number(RegObjects[i].ShellprojectedX[o]),400+Number(RegObjects[i].ShellprojectedY[o]));
                                ctx.lineTo(400+Number(RegObjects[i].ShellprojectedX[o+1]),400+Number(RegObjects[i].ShellprojectedY[o+1]))
                                ctx.strokeStyle = "black";
                                ctx.lineWidth = 2
                                ctx.stroke()
                            }
                        } 
                    
                }
            }
                // Canvas Draw Object Shells with Marking Function
                
                
                
                
                
                // Canvas draw Animation Pathing Visualisation Function
                function CanvasDrawAnimationPathing(){
                    if(ShowAnimationPathing == true){
                        
                        for (let i = 0; i < RegObjects.length; i++) {

                            if(RegObjects[i].ObjectType == "Animated"){
                            
                                
                                for (let o = 0; o < RegObjects[i].AnimationPathProjectedX.length; o++) {
                                    
                                    ctx.moveTo(400+Number(RegObjects[i].AnimationPathProjectedX[o]),400+Number(RegObjects[i].AnimationPathProjectedY[o]));
                                    ctx.lineTo(400+Number(RegObjects[i].AnimationPathProjectedX[o+1]),400+Number(RegObjects[i].AnimationPathProjectedY[o+1]));
                                    ctx.strokeStyle = "purple"
                                    ctx.lineWidth = 2
                                    ctx.stroke()
                                }
                            }
                        }
                    }
                }
                // Canvas draw Animation Pathing Visualisation Function









                // Canvas draw Animation Pathing Visualisation Function
                function CanvasDrawHitboxes(){
                    if(ShowHitboxes == true){
                        
                        for (let i = 0; i < RegObjects.length; i++) {

                            if(RegObjects[i].ObjectType == "Physics") {
                               
                                for (let o = 0; o < RegObjects[i].HitboxProjectedX.length; o++) {
                                    
                                    ctx.moveTo(400+Number(RegObjects[i].HitboxProjectedX[o]),400+Number(RegObjects[i].HitboxProjectedY[o]));
                                    ctx.lineTo(400+Number(RegObjects[i].HitboxProjectedX[o+1]),400+Number(RegObjects[i].HitboxProjectedY[o+1]));
                                    ctx.strokeStyle = "pink"
                                    ctx.lineWidth = 2
                                    ctx.stroke()
                                }
                            }
                        }
                    }
                }
                // Canvas draw Animation Pathing Visualisation Function

            </script>
            
        </body>
        </html>